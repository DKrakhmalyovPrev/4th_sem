#include <iostream> 
#include <thread>
#include <vector>
#include <mutex>
#include <atomic>
#include<array>

//Построим "неправильный" мьютекс из задания.
class peterson_mutex {
	 public: 
		 peterson_mutex() 
		 { 
			 want[0].store(false); 
			 want[1].store(false); 
			 victim.store(0); 
		 } 
		 
		 void lock(int t) 
		 {
			 victim.store(t);
			 //Здесь должна возникнуть ошибка
			 want[t].store(true); 
			 while (want[1 - t].load() && victim.load() == t) {} 
		 } 
		 
		 void unlock(int t) { 
			 want[t].store(false); 
		 } 
		 
private: 
	std::array<std::atomic<bool>, 2> want; 
	std::atomic<int> victim; 
};

/*
Идея мьютекса заключается в том, что поток ничего не делает, пока переменная "жертва" имеет его номер и его оппонент хочет работать
Когда совершается анлок, поле "желания" потока переводится в 0 и второй поток выходит из цикла ожидания по первому условию.
Если изменить порядок присвоения переменным значений, с учётом рандомного прерывания кванта операций, выделенных на работу одного потока,
может возникнуть следующая ошибка:
Оба потока вызывают lock()
Первый поток становится жертвой
Второй поток становится жертвой
Второй поток ставит метку в work[1]
Второй поток начинает работу, потому что want[1 - t]==0
Первый поток ставит метку в work[0]
Первый поток начинает работать, потому что victim==1
Оба потока одновременно входят в критическую секцию.
*/
