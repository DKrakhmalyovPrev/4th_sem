//Рассмотрим следующую реализацию мьютекса:


class tricky_mutex {
public:
   tricky_mutex() : thread_count(0)   {}

   void lock() {
       while (thread_count.fetch_add(1) > 0) {
            //Здесь вызывается следующий процесс и не происходит взаимного исключения
           thread_count.fetch_sub(1);
           // Здесь вызывается следующий процесс и происходит взаимная блокировка
       }
   }

   void unlock() {
       thread_count.fetch_sub(1);
   }

private:
   std::atomic<int> thread_count;
};
/*
Проблема взаимной блокировки:
Поток 1 лочит процесс -- переменная == 0 ->1
Поток 1 декременитует в цикле -- переменная == 1->0
Второй поток лочит процесс(До следующей проверки первым процессом условия цикла) -- переменная == 0->1
Второй поток декрементирует в цикле -- переменная == 1->0
Взаимная блокировка будет сохраняться, пока квант времени не закончится в другом месте кода.

Проблема взаимного исключения:
Поток 1 лочит процесс -- переменная == 0 ->1 
Второй поток лочит, инкрементирует и начинает работу -- переменная 1->2
Первый поток декрементирует переменную и выходит из цикла ожидания 2->1
Оба процесса будут работать параллельно до анлока.
*/
