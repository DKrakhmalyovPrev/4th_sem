//Рассмотрим следующую реализацию мьютекса:


class tricky_mutex {
public:
   tricky_mutex() : thread_count(0)   {}

   void lock() {
       while (thread_count.fetch_add(1) > 0) {
           thread_count.fetch_sub(1);
      }
   }

   void unlock() {
       thread_count.fetch_sub(1);
   }

private:
   std::atomic<int> thread_count;
};
/*
Полагаю, что гарантирует
1) Свободу от взаимной блокировки:
По крайней мере один поток будет работать, потому что изначально fetch_add==0 и пускает его в критическую сессию. После он может принимать
значения 1-2, а после unlock и в конце блока повторений -- снова становится == 0, что позволяет войти любому из других потоков.
2) Взаимное исключение:
Когда первый поток входит в критическую секцию, fetch_add==1, второй поток может только инкрементировать и декрементировать её в цикле ,
причём единожды и поочерёдно, то есть до unlock doorway-секцию он не пройдёт.
*/
